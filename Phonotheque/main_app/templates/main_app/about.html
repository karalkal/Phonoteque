{% extends 'base_plus_menu_4.html' %}
{% load static %}
{% block title %}Phonotheque - Profile of {{ searched_user.username }}{% endblock %}
<style>
    .text-black-90 {
        color: rgba(0, 0, 0, .9)
    }

    h1 {
        color: blue;
    }

    p {
        color: black;
    }
</style>

{% block main_content %}
    <div class="container-fluid tm-container-content tm-mt-60">

        {# ROW 1#}
        <div class="row p-5">
            <div class="col-lg-4 col-md-4 col-sm-12">
                <h2 class="tm-text-primary mb-5">Introduction</h2>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    Phonotheque is a basic student project created using the Python-based framework Django. <br>
                    It is intended to combine social media, online forum, data scraping and storage features. All these
                    are implemented at a very rudimentary level and Phonotheque should not be seen as anything but an
                    experiment.<br>
                    At the same time, the potential for expanding it by adding new services and components, improving
                    its design, security and functionalities is virtually unlimited. <br>
                    In brief: After successful registration and logging in, the users are given the opportunity to
                    extend their profile by entering additional data. <br>
                    They can then add their favourite albums to the database. To achieve this the website attempts to
                    fetch information from Wikipedia. If successful the album
                    data will be stored in the DB and will be linked to the relevant user (many-to-many relationship
                    using intermediary model).<br>
                    Artists' names (one-to-many relationship) will also be retrieved and stored. <br>
                    Logged in users will be able to view the profiles of other users, their shared albums and, if they
                    wish, add someone else's shared album to their own favourites. <br>
                    They can also post comments relate to album (one-to-many relationship). <br>
                    Inappropriate content can be disabled or deleted by the admins, while the superuser will have full
                    privileges to manipulate the DB.</p>
            </div>
            <div class="col-lg-8 col-md-8 col-sm-12">
                <h2 class="tm-text-primary mb-5">Entity Relationship Diagram</h2>
                <img src="https://i.ibb.co/nDtGbgR/ERD-phonotheque.png" alt="ERD-phonotheque" width="100%">

            </div>
        </div> <!-- row -->

        {# ROW 2#}
        <div class="row p-5">
            <h2 class="tm-text-primary mb-5 text-center">Accounts App</h2>
            <div class="col-lg-4 col-md-4 col-sm-12">
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    Phonotheque uses the default Django User Model. As we know there are different schools as to what is
                    the best way to customize the user model (creating a custom User model via AbstractBaseUser if the
                    intention is to change the authentication procedure or via AbstractUser if additional info about the
                    user needs to be collected/stored being quite popular).<br>
                    I decided instead to stick to the other recommended strategy of extending the default model with a
                    One-to-One relationship to a Profile model as I am perfectly happy with the Django User defaults -
                    everything works out of the box, is compatible with all third party modules while at the same time
                    the Profile model provides extendability and flexibility.</p>
                <h4 class="tm-text-primary mt-2 text-left"> Registration</h4>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    When an anonymous user wishes to create an account they are presented with the UserRegistrationForm.
                    This form takes care of the front end formatting and apart from the default Django validation
                    performs validation of the first name and second name entries – both should be with a length of
                    between 2 and 35 characters and must be satisfying the condition <code>VALID_NAME_REGEX = r"^([
                    \u00c0-\u01ffa-zA-Z'\-])+$" </code>which is a complicated way to say that our user can have a name
                    like <strong>Jérémie O'Conor-IVANOVäüïöëÿâçéèêîïôčšžñáéíóúü</strong> but cannot be named R2D2,
                    number1, st*r or f### #ff. <br>
                    Once an user is created with the default Django fields , their id, first
                    name and last name will be saved automatically in the <strong>Profile</strong> table by using the
                    following code in the<code> register</code> view:
                </p>
            </div>
            <div class="col-lg-4 col-md-4 col-sm-12">
                <code># Create the user profile as well<br>
                    new_profile = Profile.objects.create(user=new_user)<br>
                    # And copy name(s) to it<br>
                    new_profile.first_name = user_form.cleaned_data['first_name']<br>
                    if user_form.cleaned_data['last_name']:<br>
                    &nbsp;&nbsp;new_profile.last_name = user_form.cleaned_data['last_name']<br>
                    &nbsp;&nbsp;new_profile.save() </code>
                <br>
                <h4 class="tm-text-primary mt-2 text-left"> Profile Editing</h4>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    The profile is editable (names and email can be changed, username cannot) and additional data
                    can be added if the user wishes to do so – gender (select from pre-defined options), description,
                    date of birth (must be in range between today and 1920) and photo (the development version was based
                    on uploading actual image files but deploying it is a bit too much hassle and requires submitting
                    credit card details for verification which is not really desirable for the purpose of this
                    project, therefore for development I switched to providing an URL to a profile photo instead).<br>
                    The edit view (name could could have been more appropriate, I guess…) presents the user with a
                    form to fill which actually consists of 2 forms - <code>user_form = UserEditForm </code> and <code>profile_form
                    = ProfileEditForm</code>. By using the <code>@login_required</code> decorator the view makes sure
                    only the logged-in user can edit their profile. <br>
                    Once these have been filled and verified the data is
                    being saved in the relevant columns in the <strong>User</strong> and <strong>Profile</strong>
                    models. <br>
                    The user is then redirected to their own profile details page where they can view the
                    updated data and a confirmation message is being displayed.
                </p>
            </div>
            <div class="col-lg-4 col-md-4 col-sm-12">
                <h4 class="tm-text-primary mt-0 text-left"> Logging In</h4>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    Logging in functionality relies on the default Django CBV LoginView. By overwriting its <code>def
                    __init__(self, *args, **kwargs)</code> method we ensure that the login form is displayed with the
                    required styling – this approach seems more straightforward than creating a custom
                    AuthenticationForm. The success URL is the logged in user’s dashboard (will be explained later).<br>
                    Once logged in the Register button in the main manu will be replaced with a Profile button where
                    users will be able to edit their profiles.
                </p>
                <h4 class="tm-text-primary mt-2 text-left"> Logging Out</h4>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    Logging out also relies on the default LogoutView. Once logged out, the user will be redirected to
                    the index page by using <code>next_page = 'index_page'</code> while overriding its <code> def
                    dispatch(self, request, *args, **kwargs) </code>method will add appropriate messages (“You have
                    successfully logged out from your account.” and “You can either close this tab or log in again”) to
                    be displayed as well
                </p>
                <h4 class="tm-text-primary mt-2 text-left">View other users profiles</h4>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    Logged in users can view profiles of other registered user. It is debatable whether this
                    functionality is better suited for accounts app or the main app, but I concluded this was the more
                    appropriate place for it. The relevant view DetailView is named ProfileDetailView and by using
                    <code>LoginRequiredMixin</code> we make sure only logged-in users can view the profile info of
                    others. By overriding <code>def get_context_data(self, **kwargs)</code> method data for the
                    searched_user is added to the context variable and can then be passed to the relevant template.</p>
                <h4 class="tm-text-primary mt-2 text-left"> Password change </h4>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    Logged in users can change their passwords by inheriting the PasswordChangeView CBV from
                    <code>django.contrib.auth.views</code>. Again, the relevant form is displayed with the required
                    styling by overwriting its <code>def __init__(self, *args, **kwargs)</code> method.
                </p>
            </div>
        </div> <!-- row -->

        {# ROW 3#}
        <div class="row p-5">
            <h2 class="tm-text-primary mb-5 text-center">Main App</h2>
            <div class="col-lg-4 col-md-4 col-sm-12">
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    The main app allows users to share their favourite albums as well as to discuss albums already
                    shared on the platform with other users. Obviously, an album is a very specific object (not only in
                    the programming sense of the word) – it is not comparable to sharing someone’s personal experiences
                    or ideas on a blog site or even listing items for sale on an online shop. A music album is an unique
                    item – it has properties which remain constant for everyone, anywhere and anytime -
                    its cover image, date of issue or musicians involved won't change. We need to somehow ensure our
                    website can <strong>identify the correct object</strong>> and make it available for sharing, liking
                    or whatever else is required. <br>
                    Therefore, for this scenario to be meaningful it is essential to gather our data from a reliable
                    source and luckily Wikipedia (God bless everyone involved in the project!) provide great API
                    which interacts perfectly with Django/Python.<br>
                    Basically, the general idea is to retrieve album data (I won’t call our basic searches ‘web
                    scraping’ but to some degree this is what we are doing here.) from Wikipedia’s API which has been
                    imported in the project (alongside some other modules which seem to have mutual dependencies). <br>
                    Once obtained, the album data is being displayed and if the user wishes they can add it to
                    their personal <strong>Collection </strong> albums (see ERD for clarification). <br>
                    By doing this they also create a
                    record for the Album in the DB as well as for the Artist but only if these are not already present
                    there. <br>
                    Then can then view their favourite albums in their personal dashboard and for each album they
                    can view additional info like comments from users and which other users, if any, have
                    liked this album (displayed in chronological order). <br> As a side note, I would say this
                    particular part of the application provides significant
                    potential and incentive to continue working on it as there is a wide range of possibilities to
                    add new features – for example IM system, tagging system, automatic recommendations based on custom
                    criteria, recommendations from other users, creation of interest groups, ‘friendship’ FB-style…</p>
                <h4 class="tm-text-primary mt-2 text-left">Home Page/Index</h4>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    The index page is accessible for both anonymous and logged-in users. The difference is that the
                    former will see a short message explaining the raison d'etre of this web page. Logged-in users
                    presumably will not need this.<br>
                    The index page functionality is based on Django’s default ListView. It implements pagination and the
                    template will display a gallery-style list of all albums shared on the platform (ordered
                    chronologically, newest first) as well as the number of users who have liked each of them.</p>
                <h4 class="tm-text-primary mt-2 text-left">Album Details</h4>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    <code>AlbumDetailView(views.DetailView)</code> is also visible to anonymous and logged-in users.
                    Anonymous users can view the stored album information and click a link to the full Wikipedia article
                    (opens in new tab). However, logged-in users will be able to: </p>
                <ul style="color: #001421; font-size: 1.25em; list-style-type: square;">
                    <li> delete the album from their collection if it is present there</li>
                    <li> add the album to their collection if it is not present there</li>
                    <li> view comments posted by users</li>
                    <li> post a comment</li>
                    <li> see which users have liked the same album</li>
                    <li> access the profile pages of these users by being redirected to the relevant URL</li>
                </ul>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    To achieve all that the view performs a series of queries which are then added to the context (with
                    <code> get_context_data(self, **kwargs)</code>) alongside the Comment form and sent to the template.
                    The template then has access to variables like <code>others_who_liked_it</code>, <code>album_to_unlike_pk</code>,
                    <code>liked_by_current_user</code>.
                </p>
            </div>

            <div class="col-lg-4 col-md-4 col-sm-12">
                <h4 class="tm-text-primary mt-2 text-left"> Artist Album List </h4>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    The artist name will be clickable in the album details template and will redirect to another
                    <code>ListView</code> whose template will display a page which looks visually very similar to the
                    index one but with albums related to the selected artist only. This is being achieved by overriding
                    the methods:<br>
                    <code> def get_queryset(self): # get queryset/albums_list for this specific artist<br>
                        return super(ArtistDiscographyView, self).get_queryset() \<br>
                        .filter(artist_id=self.kwargs['pk'])<br>
                        <br>
                        def get_context_data(self, *, object_list=None, **kwargs):<br>
                        context = super(ArtistDiscographyView, self).get_context_data()<br>
                        artist = Artist.objects.get(pk=self.kwargs['pk'])<br>
                        context['artist_name'] = artist.name<br>
                        return context<br>
                    </code>
                    Since the Album table only stores artist_id as foreign key we need to get the name of the artist and
                    add it to the context.</p>

                <h4 class="tm-text-primary mt-2 text-left"> Comments </h4>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    The <code>class CommentCreateView</code> inherits from <code>views.CreateView</code> and
                    <code>PermissionRequiredMixin</code>,
                    i.e. only logged-in users will be able to view comments and post new ones. If an user crates a new
                    comment via its related <code>ModelForm</code> it will be saved in the DB by creating record
                    of its text content as well as the user and album id’s it is related to via its FK.<br>
                    <code>
                        def form_valid(self, form):
                        &nbsp;&nbsp;comment = form.save(commit=False)
                        &nbsp;&nbsp;comment.user = self.request.user
                        &nbsp;&nbsp;comment.album = Album.objects.get(wiki_id=self.kwargs['album_wiki_id'])
                        &nbsp;&nbsp;return super().form_valid(form)
                    </code>
                    The view will then redirect again to the same album info page where the user’s newly published
                    comment will be visible at the top as comments are displayed by their creation time, most recent
                    first.</p>

                <h4 class="tm-text-primary mt-2 text-left">Dashboard</h4>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    Logged-in users have access to their personalized dashboard. Actually this is the page they are
                    being redirected to as soon as they are logged in. <br>It lists, again gallery-style and with
                    pagination (4 items on a page) their favourite albums while the two forms below initiate the
                    Wikipedia search - these are actually are the bottom of the main logic of the webpage – titled
                    ‘Search for an album by artist and title…’ (uses forms.Form) and ‘... or paste album's Wikipedia
                    link below’.<br>
                    They both redirect to the relevant URLs and, subsequently, to either
                    <code>find_album_by_title_and_artist(request)</code> or <code>
                    find_album_by_url(request)</code><br>
                    Again, this section of the website could be extended by adding all sorts of functionalities -
                    any sort of data a proper music lover might get from or about like-minded people could be displayed
                    there.
                </p>

                <h4 class="tm-text-primary mt-2 text-left">Retrieving the data from Wikipedia</h4>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    Each of these views calls a separate function which does the Wikipedia search for us.<br>
                    1) <code>def get_wiki_info_by_album_name(search_term)</code> will initially retrieve a <strong>wikipedia.page
                    object</strong> from the top result from Wikipeadia’s API with the search_term argument (please
                    note: the search term provided by <code>find_album_by_title_and_artist(request)</code> will
                    initially be only the <strong>album name only</strong>, if unsuccessful it will search with artist
                    name added too.)<br>If the string 'album' is not present in the summary of the Wikipedia article
                    returned to us it will retrieve the first 8 results, will look for the string ‘album’ in these as
                    well and if again it finds nothing will return None, None (for album and artist) to
                    the view, the dashboard page will reload with an appropriate message. If successful though it will
                    send the wikipadia.page object to a function called assign_values(page_object).<br>
                </p>
            </div>

            <div class="col-lg-4 col-md-4 col-sm-12">
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    2) <code>def get_wiki_info_from_url(album_url)</code> works in a similar and maybe not the optimal
                    manner - there might be a more intelligent method to get wikipedia info from a wikipedia link rather
                    than obtain a string from the link itself and then use it to search the website. It will strip
                    everything from the link provided apart from the actual article name
                    (https://en.wikipedia.org/wiki/Ride_the_Lightning becomes just Ride_the_Lightning), will replace
                    most of the undesired escaped characters (Ride_the_Lightning becomes Ride the Lightning) and will
                    invoke the same <code> assign_values(page_object) </code>function with the wikipadia.page object if
                    found, if not it will return None, None (for album and artist) to the view.<br>
                    The <code>assign_values(page_object)</code> function will create a dictionary with all album data
                    contained in the page_object, removing everything contained in round brackets from article names
                    (Animals (Pink Floyd album) becomes just Animals), including an album cover URL.<br>
                    The artist name will be retrieved from a particular section in the Wikipedia’s article html – each
                    Wikipedia album page has a side section titled something like ‘Studio album by Massive Attack’. By
                    searching the raw html with if <code>'album&#60;/a&#62;&#32;by'</code> in raw_html and with some
                    slicing, splitting, cutting and torturing we can hopefully get the artist name and return it to the
                    relevant function alongside the album data.<br>
                    Then the above-mentioned functions will return themselves the wiki_info, artist to the corresponding
                    views. </p>

                <h4 class="tm-text-primary mt-2 text-left">Saving the data from Wikipedia</h4>
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    As mentioned before the data from Wikipedia will be returned to either
                    <code>find_album_by_title_and_artist(request) view</code> or <code>find_album_by_url(request)
                    view</code>. The first one basically prepares the search term based on the user input and invokes
                    the above-mentioned function with <code>album_wiki_info, artist_name =
                    get_wiki_info_by_album_name(search_term)</code>.<br>
                    If None is returned the view will redirect back to dashboard with the message We couldn't find an
                    album called {album_name} by {searched_artist}.<br>
                    If successful it will send the data to the template called <code>album_found.html</code> and,
                    crucially, will <strong>‘attach’ the retrieved data to the session</strong> - <code>request.session['data']
                    = artist_name, album_wiki_info</code> so that it could be used/saved later if the user confirms in
                    <code>album_found.html</code> that they wish to save this album.
                    The <code>find_album_by_url(request)</code> view works in a very similar way.<br>
                    If the user confirms the displayed album is indeed what they were looking for, they will be
                    redirected to save_artist_album_data(request). Then we follow the following consequence of steps to
                    save the data:<br>
                    1) Unpack the additional data we stored in the session with artist_name, album_wiki_info =
                    request.session['data']<br>
                    2) Check if artist already in DB, if not create record (we will need that later if we have need to
                    save the album in our DB).<br>
                    3) We try to get the album with this wiki_id from DB.<br>
                    4) If it is there (no exception is raised) we check if this album is already in users collection and
                    if yes redirect to dashboard again with the message The Album {album.title} by {album.artist} is
                    already in your favourites'.<br>
                    5) If getting the album from the DB fails with ObjectDoesNotExist exception we will create a new
                    Album object adding the artist_object as FK too.<br>
                    6) Once we make sure artist name is stored in DB we get it in case we need it as a FK.<br>
                    7) Then we can it to the users own collection with Collection.objects.create(user=user, album=album)
                    and display message 'The album {album.title} by {album.artist} has been saved in your
                    favourites'<br>
                </p>
            </div>
        </div> <!-- row -->

        <div class="row p-5">
            <h2 class="tm-text-primary mb-5 text-center">Admin Panel/Functionalities</h2>
            <div class="col-lg-6 col-md-6 col-sm-12">
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    The permissions system of Phonotheque is based on 3 staff groups with different level of
                    authorisation to manage the DB. Obviously, the Super Users group will have full add, delete, change,
                    view privileges. <br>
                    A group of lower level moderators can de-activate comments and users (if for example an
                    inappropriate content has been detected) and another group will be able to delete these comments and
                    users if required.
                </p>
            </div>
            <div class="col-lg-6 col-md-6 col-sm-12">
                <p class="col-12 tm-text-primary" style="color: #001421; font-size: 1.25em">
                    There is also a GUI covering the Comment model where this de-activation/deletion can be made.<br>
                    If an user logs in as moderator they can perform the aforementioned activities and unlike regular
                    users they will be able to see inactive comments as well. <br>
                    In other words users will be able to view
                    only active comments unless their permission level is_staff is True – they will then be able to view
                    the de-activated ones too.
                </p>
            </div>

        </div>


    </div> <!-- container-fluid, tm-container-content -->
{% endblock %}